# -*- coding: utf-8 -*-
"""002_jma_rnn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/177pG20JHBs6xBNaanfjaYKWHImFm1xkE
"""

# Commented out IPython magic to ensure Python compatibility.
import torch


import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset
import pandas as pd
import numpy as np

from matplotlib import pyplot as plt
# %matplotlib inline

# 気象庁が配布している東京の日中平均気温のデータ (2012年〜2020年) をダウンロードして読み込む
# https://www.data.jma.go.jp/gmd/risk/obsdl/index.php
data = pd.read_csv("./jma_tokyo_2012_2020_temperture.csv", encoding="shift-jis", skiprows=[0,1,2,4])
data

temperature = data["平均気温(℃)"]
temperature

train_x = temperature[:1827]
test_x = temperature[1827:]
train_x = np.array(train_x)
test_x = np.array(test_x)

# ミニバッチ用のデータを作る
window_size = 180
temperature_series = []
train_X_series = []

for i in range(0, len(train_x) - window_size):
  # 一個ずつデータをずらしながら格納していく
  temperature_series.append(train_x[i:i+ window_size])

train_X_series = np.array(temperature_series)
pd.DataFrame(train_X_series)

class Net(nn.Module):
  def __init__(self):
    super(Net, self).__init__()
    self.fc1 = nn.Linear(window_size, 128)
    self.fc2 = nn.Linear(128, 64)
    self.fc3 = nn.Linear(64, 128)   
    self.fc4 = nn.Linear(128, 180)
  
  def forward(self, x):
    x = F.relu(self.fc1(x))
    x = self.fc2(x)
    x = F.relu(self.fc3(x))
    x = self.fc4(x)
    return x

model = Net()

# 最小二乗誤差
#  ((input - target) **2).mean()
criterion = nn.MSELoss()

# optimizerはAdam
optimizer = optim.Adam(model.parameters(), lr=0.001)

# 2000エポック回す
for epoch in range(2000):
  total_loss = 0
  optimizer.zero_grad()

  # ランダムに特徴量を格納する
  features_x = []

  for i in range(100):
    random_data_index = np.random.randint(0, len(train_X_series))
    # 訓練データ、train_X_seriesの中から、ランダムに特徴量を取得して格納する。
    features_x.append(train_X_series[random_data_index])

  # ランダムに抽出した特徴量をニューラルネットワークに通してyを得る
  features_x = torch.Tensor(features_x)
  y = model(features_x)

  # 誤差を算出
  loss = criterion(y, features_x)

  # 勾配を計算
  loss.backward()
  optimizer.step()
  total_loss += loss.item()

  if (epoch + 1) % 100 == 0:
    print(epoch + 1, total_loss)


plt.plot(features_x.data[0].numpy(), label="x")
plt.plot(y.data[0].numpy(), label="y")
plt.legend(loc="upper right")

# 誤差を検出する

test_x_extract = []
test_x_extract.append(test_x[0:180])
test_x_extract.append(test_x[180:360])
test_x_tensor = torch.Tensor(np.array(test_x_extract, dtype="float32"))

pd.DataFrame()

predict = model(test_x_tensor)

plt.plot(test_x_tensor.flatten(), label="original")
plt.plot(predict.data.flatten(), label="predict")
plt.legend(loc="upper right")

test = test_x_tensor.flatten()
predict = predict.data.flatten()

losses = []

for i in range(0, 360):
  diff = test[i] - predict[i]
  loss = pow(diff, 2)
  losses.append(loss)
  
losses = torch.Tensor(losses)

# 一番誤差が大きい値
max_loss_value = torch.max(losses)

# 一番誤差が大きい値で割る。最大値は1となる。
# 比率で誤差を表示する。
loss_ratios = losses / max_loss_value
plt.plot(loss_ratios)